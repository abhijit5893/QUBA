package Library.newlib;

/*Generated by MPS */

import javax.swing.JOptionPane;
import org.w3c.dom.NodeList;
import javax.swing.JTable;
import java.awt.Dimension;
import javax.swing.JScrollPane;
import javax.swing.JFrame;
import javax.swing.BoxLayout;
import java.awt.Color;
import javax.swing.JTextPane;
import javax.swing.text.StyledDocument;
import javax.swing.text.Style;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import java.util.Set;
import java.util.HashSet;

public class QuestionBank {

  /**
   * This class belongs to the business layer (the logical part). XML is used as the Question bank. So any applications 
   * pertaining to managing the Question bank is accomplished with the help of this class.
   */
  private static String PATH;
  public XmlMediator xmlTool;
  public int totalCount;


  public QuestionBank() {
    xmlTool = new XmlMediator(manifest.getQBPath());
  }



  /**
   * Initialize the Absolute path of the Question bank
   */
  public static void setPath() {
    PATH = manifest.getQBPath();
  }




  /**
   * Insert a new question into the question bank
   */
  public void insert(Question q) throws Exception {
    xmlTool.addNode(q);
    JOptionPane.showMessageDialog(null, "Inserted!");
  }




  /**
   * Update a question for a particular category with a corresponding value
   */
  public void update(int questionId, String field, String value) throws Exception {
    xmlTool.updateNode(questionId, field, value);
    JOptionPane.showMessageDialog(null, "Updation Completed!");
  }




  /**
   * This function is used to search by category and value. The number of required search results is the third argument.
   * If the third parameter is an empty string, all the search results are considered for display
   */
  public void searchBy(String category, String value, String requiredNumber) throws Exception {
    NodeList searchResults;
    searchResults = xmlTool.searchByCategory(category, value, requiredNumber);
    int resultsCount = searchResults.getLength();

    if (requiredNumber.equalsIgnoreCase("")) {
      requiredNumber = "" + resultsCount;
    }

    // Representing the data as table in java swing 
    // Here 6 refers to the first 6 sub tags of the question node 
    Object[][] tableObjects = new Object[Integer.parseInt(requiredNumber)][6];
    String[] title = new String[6];
    for (int i = 0; i < 6; i++) {
      title[i] = searchResults.item(0).getChildNodes().item(i).getNodeName();
    }
    searchResults.item(0).getChildNodes().item(0).getNodeName();

    for (int i = 0; i < Integer.parseInt(requiredNumber); i++) {
      for (int j = 0; j < 6; j++) {
        tableObjects[i][j] = searchResults.item(i).getChildNodes().item(j).getTextContent();
      }
    }
    JTable table = new JTable(tableObjects, title);
    table.setRowHeight(table.getRowHeight() + 10);
    table.setIntercellSpacing(new Dimension(15, 2));
    JScrollPane scrollPane = new JScrollPane(table);
    JFrame frame = new JFrame();
    frame.setLayout(new BoxLayout(frame.getContentPane(), BoxLayout.Y_AXIS));
    frame.setMinimumSize(new Dimension(400, 300));
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    frame.setTitle("Search Results : " + resultsCount + " Results found");
    frame.setBackground(Color.LIGHT_GRAY);
    JTextPane textPane = new JTextPane();
    StyledDocument doc = textPane.getStyledDocument();
    Style style = textPane.addStyle("Style1", null);
    SimpleAttributeSet style1 = new SimpleAttributeSet();
    StyleConstants.setAlignment(style1, StyleConstants.ALIGN_CENTER);
    StyleConstants.setFontFamily(style1, "Times New Roman");
    StyleConstants.setForeground(style1, Color.BLACK);
    StyleConstants.setFontSize(style1, 28);
    textPane.setParagraphAttributes(style1, true);
    textPane.setEditable(false);

    try {
      doc.insertString(doc.getLength(), "SEARCH RESULTS...\n", style1);
    } catch (Exception e) {
      JOptionPane.showMessageDialog(null, "Some error occured! Please try again!");
    }
    frame.add(textPane);
    frame.add(scrollPane);
    frame.pack();
    frame.setVisible(true);
  }




  /**
   * As the name suggests, this function is used to view all the records present in the question bank
   */
  public void viewAll() throws Exception {
    NodeList searchResults = xmlTool.fetchAll();
    int resultCount = searchResults.getLength();
    int attribute_size = 0;
    if (searchResults.item(0).getChildNodes().getLength() > 7) {
      attribute_size = searchResults.item(0).getChildNodes().getLength();
    } else {
      attribute_size = 7;
    }
    Object[][] tableObjects = new Object[resultCount][attribute_size];
    String[] title = new String[attribute_size];
    for (int i = 0; i < attribute_size; i++) {
      if (i >= searchResults.item(0).getChildNodes().getLength()) {
        title[i] = "";
      }
      if (i < searchResults.item(0).getChildNodes().getLength()) {
        title[i] = searchResults.item(0).getChildNodes().item(i).getNodeName();
      }

    }

    for (int i = 0; i < searchResults.getLength(); i++) {
      for (int j = 0; j < attribute_size; j++) {
        if (j >= searchResults.item(i).getChildNodes().getLength()) {
          tableObjects[i][j] = "";
        }
        if (j < searchResults.item(i).getChildNodes().getLength()) {
          tableObjects[i][j] = searchResults.item(i).getChildNodes().item(j).getTextContent();
        }

      }
    }
    JTable table = new JTable(tableObjects, title);
    table.setRowHeight(table.getRowHeight() + 10);
    table.setIntercellSpacing(new Dimension(15, 2));
    JScrollPane scrollPane = new JScrollPane(table);
    JFrame frame = new JFrame();
    frame.setLayout(new BoxLayout(frame.getContentPane(), BoxLayout.Y_AXIS));
    frame.setMinimumSize(new Dimension(400, 300));
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    frame.setTitle("Search Results : " + resultCount + " Results found");
    frame.setBackground(Color.LIGHT_GRAY);
    JTextPane textPane = new JTextPane();
    StyledDocument doc = textPane.getStyledDocument();
    Style style = textPane.addStyle("Style1", null);
    SimpleAttributeSet style1 = new SimpleAttributeSet();
    StyleConstants.setAlignment(style1, StyleConstants.ALIGN_CENTER);
    StyleConstants.setFontFamily(style1, "Times New Roman");
    StyleConstants.setForeground(style1, Color.BLACK);
    StyleConstants.setFontSize(style1, 28);
    textPane.setParagraphAttributes(style1, true);
    textPane.setEditable(false);
    try {
      doc.insertString(doc.getLength(), "Question Bank Content\n", style1);
    } catch (Exception e) {
      JOptionPane.showMessageDialog(null, "Some error occured! Please try again!");
    }
    frame.add(textPane);
    frame.add(scrollPane);
    frame.pack();
    frame.setVisible(true);
  }




  /**
   * Remove or delete a question from the question bank
   */
  public void delete(int q) throws Exception {
    xmlTool.removeNode(q);
    JOptionPane.showMessageDialog(null, "Deletion Completed!");
  }




  /**
   * Show report based on one or more categories
   */
  public void showReport(String[] category) throws Exception {
    xmlTool.prepareReport(category);
  }




  /**
   * Function to load the autocompletion menu.
   * If both the parameters are empty string, the function returns all the different types
   * If the first parameter is provided and second parameter is empty string, the function returns all the subjects corresponding to the types
   * If both the parameters are given, the function returns all the difficulty level corresponding to that type and subject
   */
  public String[] showMenu(String type, String subject) throws Exception {
    Set<String> results = new HashSet<String>();
    results = xmlTool.prepareMenu(type, subject);

    String[] resultingStrings = new String[results.size()];
    for (int i = 0; i < results.size(); i++) {
      resultingStrings[i] = (String) results.toArray()[i];
    }
    return resultingStrings;
  }




  /**
   * This function returns the list of subjects that are common to all the types given as input.
   */
  public String[] showLoopTypeMenu(String[] type) throws Exception {
    Set<String> results = new HashSet<String>();
    results = xmlTool.prepareLoopTypeMenu(type);
    String[] resultingStrings = new String[results.size()];
    for (int i = 0; i < results.size(); i++) {
      resultingStrings[i] = (String) results.toArray()[i];
    }
    return resultingStrings;
  }




  /**
   * This function returns all the difficulty levels that are common to the provided type and its corresponding subjects
   */
  public String[] showLoopSubMenu(String[] type, String[] sub) throws Exception {
    Set<String> results = new HashSet<String>();
    results = xmlTool.prepareLoopSubMenu(type, sub);
    String[] resultingStrings = new String[results.size()];
    for (int i = 0; i < results.size(); i++) {
      resultingStrings[i] = (String) results.toArray()[i];
    }
    return resultingStrings;
  }




  /**
   * This function takes context string as input. It returns a array of string possessing the content corresponding to the given context
   */
  public String[] searchByMenu(String context) throws Exception {
    Set<String> res = new HashSet<String>();
    res = xmlTool.SearchByMenu(context);
    System.out.println(res);
    String[] resStrings = new String[res.size()];
    for (int i = 0; i < res.size(); i++) {
      resStrings[i] = (String) res.toArray()[i];
    }
    return resStrings;
  }
}
